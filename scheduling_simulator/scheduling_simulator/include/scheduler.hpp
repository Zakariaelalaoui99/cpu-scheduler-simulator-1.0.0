/**
 * \file scheduler.hpp
 * \brief Scheduler engine for the Scheduling Simulator.
 * \details Provides the discrete-event simulation core that coordinates
 *          process and thread scheduling using pluggable algorithms.
 *          Supports process-only, kernel-level thread, and user-level
 *          thread scheduling modes, as described in "Moderne Betriebssysteme".
 * \copyright
 *   (c) Scheduling Simulator contributors. All rights reserved.
 * \date 2025-08-24
 */

#pragma once
#include <vector>
#include <memory>
#include "process.hpp"
#include "ganttentry.hpp"
#include "schedulingalgorithm.hpp"

/**
 * @class Scheduler
 * @brief Discrete-event simulation engine for scheduling experiments.
 *
 * The Scheduler owns the workload (processes and threads), delegates
 * CPU assignment to the selected @ref SchedulingAlgorithm, and records
 * the resulting Gantt chart timeline. It supports three execution modes:
 * - **ProcessOnly**: schedule processes directly as single entities.
 * - **ThreadKernel**: flatten threads to pseudo-processes and schedule
 *   them at kernel level.
 * - **ThreadUser**: schedule processes as units, then multiplex their
 *   internal threads in user space with Round-Robin using @ref threadQuantum.
 *
 * The Scheduler also accounts for context switch costs and exposes
 * per-process and per-thread statistics (completion, turnaround, waiting).
 *
 * @see SchedulingAlgorithm
 * @see Process
 * @see Thread
 */
class Scheduler {
public:
    /** @brief Execution mode of the simulation. */
    enum class Mode {
        ProcessOnly,   ///< Only processes are scheduled.
        ThreadKernel,  ///< Threads are scheduled individually (kernel-level).
        ThreadUser     ///< Processes scheduled, then threads multiplexed (user-level).
    };

    /**
     * @brief Construct a Scheduler with an optional initial algorithm.
     * @param alg Unique pointer to a SchedulingAlgorithm (may be null initially).
     */
    explicit Scheduler(std::unique_ptr<SchedulingAlgorithm> alg = nullptr)
        : m_algorithm(std::move(alg)) {}

    // configuration
    /**
     * @brief Set or replace the active scheduling algorithm.
     * @param alg New algorithm (ownership transferred).
     */
    void setAlgorithm(std::unique_ptr<SchedulingAlgorithm> alg) { m_algorithm = std::move(alg); }

    /**
     * @brief Set the context switch cost.
     * @param cs Time units to add between segments when the CPU switches to another process.
     */
    void setContextSwitch(int cs) { m_contextSwitch = cs; }

    /**
     * @brief Get the context switch cost.
     * @return Context switch duration in time units.
     */
    int  contextSwitch() const { return m_contextSwitch; }

    /**
     * @brief Set the current execution mode.
     * @param m One of @ref Mode (ProcessOnly, ThreadKernel, ThreadUser).
     */
    void setMode(Mode m) { m_mode = m; }

    /**
     * @brief Get the current execution mode.
     * @return The active @ref Mode.
     */
    Mode mode() const { return m_mode; }

    /**
     * @brief Set the quantum used for user-level thread scheduling.
     * @param q Quantum in time units.
     */
    void setThreadQuantum(int q) { m_threadQuantum = q; }

    /**
     * @brief Get the quantum used for user-level thread scheduling.
     * @return Quantum in time units.
     */
    int  threadQuantum() const { return m_threadQuantum; }

    // processes / threads
    /**
     * @brief Add a process to the workload.
     * @param p Process instance to add.
     */
    void addProcess(const Process& p) { m_processes.push_back(p); }

    /**
     * @brief Remove a process from the workload.
     * @param pid Process ID to remove.
     */
    void removeProcess(int pid);

    /**
     * @brief Add a thread to an existing process.
     * @param pid Process ID that will own the new thread.
     * @param th Thread instance to add.
     * @return True if process was found and thread added, false otherwise.
     */
    bool addThreadToProcess(int pid, const Thread& th);

    /**
     * @brief Clear the current workload and results.
     */
    void clear() { m_processes.clear(); m_gantt.clear(); }

    // run
    /**
     * @brief Execute the simulation using the current algorithm and mode.
     *
     * Dispatches to mode-specific methods:
     * - @ref executeProcessOnly
     * - @ref executeThreadKernel
     * - @ref executeThreadUser
     */
    void execute();

    // results
    /**
     * @brief Get the latest process results after simulation.
     * @return Vector of processes with computed metrics.
     */
    std::vector<Process> getResults() const { return m_processes; }

    /**
     * @brief Get the Gantt chart entries generated by the last run.
     * @return Vector of GanttEntry structures (pid, tid, start, end).
     */
    std::vector<GanttEntry> getGantt() const { return m_gantt; }

private:
    void executeProcessOnly();   ///< Internal: run process-only scheduling.
    void executeThreadKernel();  ///< Internal: flatten threads to pseudo-processes and schedule.
    void executeThreadUser();    ///< Internal: schedule processes, then multiplex threads in user space.

    static int sumRemaining(const std::vector<Thread>& ts);   ///< Helper: sum of remaining burst times.
    static int firstArrival(const std::vector<Thread>& ts);   ///< Helper: earliest arrival among threads.

private:
    std::vector<Process> m_processes; ///< Workload processes.
    std::unique_ptr<SchedulingAlgorithm> m_algorithm; ///< Current scheduling algorithm.
    int m_contextSwitch{0};  ///< Context switch overhead.
    Mode m_mode{Mode::ProcessOnly}; ///< Current scheduling mode.
    int  m_threadQuantum{1}; ///< Quantum for user-level thread scheduling.
    std::vector<GanttEntry> m_gantt; ///< Timeline of scheduled CPU segments.
};
